## Пространство имен распространяется на:

* константы,
* функции,
* классы,
* интерфейсы,
* трейты.

## Пространство имен позволяет:

1. Избежать конфликта имен.

<i>Например, в Вашем коде есть класс User и в сторонней библиотеке есть класс User, при подключении их в одном классе
произойдет конфликт имен. Пространство имен позволяет добавлять к имени класса префикс, например SomeLibrary\User (для
библиотеки) и MyCode\User (для собственного кода). В таком случае мы получаем классы с разными именами и можем
использовать их без проблем.</i>

2. Создавать псевдонимы для очень длинных имен.

<i>Например, мы можем сказать, что к классу в данном файле нужно обращаться не по его длинному имени, а по псевдониму,
например use ClassWithLongName as Short.</i>

## Правила объявления пространства имен:

1. Пространство имен объявляется с помощью ключевого слова `namespace` сразу после открывающего php тега (пробелы не
   допускаются), но после слова declare, если оно используется.

2. Пространство имен должно начинаться с буквы или символа подчеркивания, за которым следует любое количество букв, цифр
   или символов подчеркивания.

3. Разрешено иметь несколько пространств имен в одном файле.

4. Разрешено использовать одно пространство имен в разных файлах.

## Пример объявления пространства имен:

      namespace Animals;

Допустим, в пространстве Animals находится класс Mouse, тогда к классу при использовании будет добавляться префикс
Animals и получится Animals\Mouse.

## Как файлы и каталоги, пространства имён PHP позволяют создавать иерархию имён.

Таким образом, имя пространства может быть определено с подуровнями:

## Пример подпространства имен:

`namespace Animals\Wild;` или `Animals\Pets;` или `Library\Core\Database;` и тд.

Допустим, в пространстве Animals\Wild находится класс Fox, тогда префикс класса будет Animals\Fox и получится
Animals\Wild\Fox.

## Пространства имен можно определять в соответствии с иерархией каталогов в файловой системе, где подкаталоги соответствуют подпространству имен.

## Использование пространств имен и имена классов:

1. Неполное имя класса (для обращения к классу в текущем пространстве имен).

Например, создан файл Mouse.php со следующим содержимым:

      namespace Animals;
      
      class Mouse {...}

Обращение к классу в текущем пространстве (Animals) будет происходить по неполному имени:

      $jerry = new Jerry();

2. Полное имя (для обращения к классу из подпространства имен).

Например, создан еще один файл Dog.php со следующим содержимым:

      namespace Animals\Pets;
      class Dog {...}

В файле Mouse.php мы хотим подключить и обращаться к классу Dog:

      require_once 'Dog.php';

      Пространство Pets является подпространством Animals. 
      И из пространства Animals мы будем обращаться к классу Dog по полному имени:
      
      $dog = new Pets\Dog();

3. Абсолютное имя (для обращения к классу из другого пространства).

Например, есть файл Farmer со следующим содержимым:

      namespace Farm\People;
      class Farmer {...}

В файле Mouse.php мы хотим подключить и обращаться к классу Farmer:

      require_once 'Farmer.php';

      Пространство Farm\People никак не связано с пространством Aminals. 
      Из пространства Animals мы будем обращаться к Farmer по абсолютному имени:
      
      $farmer = new \Farm\People\Farmer();

## Импорты (use) и псевдонимы (as).

В php есть возможность ссылаться на внешнее абсолютное имя по псевдониму или импортированию. Перепишем файл Mouse.php с
использованием импорта:

      namespace Animals;

      use Pets\Dog;
      use Farm\People\Farmer as Owner;

      require_once 'Dog.php'; 
      require_once 'Farmer.php'; 

      $dog = new Dog();
      
      Благодаря псевдониму в текущем файле мы будем обращаться к классу Farmer по имени Owner.
      
      $farmer = new Owner();

## Автозагрузка

Механизм автоматического подключения классов при первом обращении 

## Автозагрузка через composer и psr-4.

Загрузчик классов, реализованный в Composer очень популярен, а стандарт psr-4 говорит как надо называть классы, чтобы по
полному имени класса узнать путь к файлу (чтобы потом его подключил автозагрузчик).


composer.json